#!/usr/bin/env python

from datetime import datetime,timedelta
now = datetime.now()
monday = datetime(year=1970,month=1,day=5)

import sys
if sys.version_info.major == 2:
    from ConfigParser import ConfigParser
else:
    from configparser import ConfigParser
from argparse import ArgumentParser
from subprocess import check_call,PIPE,Popen,CalledProcessError
from os.path import join,exists,basename,lexists,realpath,dirname
from os import makedirs, listdir, symlink, remove, rename

timestamp_strp = "%Y%m%d_%H%M%S_%f"

parse_timestamp = lambda loc: datetime.strptime(basename(realpath(loc)),timestamp_strp)

class Snapshot(object):
    def __init__(self,subvolume,timestamp_str):
        self.subvolume = subvolume
        self.loc = join(self.subvolume,".incrbtrfs","timestamp",timestamp_str)
        self.timestamp_str = timestamp_str
        self.timestamp = datetime.strptime(timestamp_str,timestamp_strp)
        self.keep = False

    def __repr__(self):
        ret = self.loc
        if self.keep:
            ret += " KEEP"
        return ret

def round_time(timestamp):
    timestamp = timestamp.replace(minute=0,second=0,microsecond=0)
    return timestamp

def calc_index(snapshot_dir,snaptype):
    timestamp = round_time(parse_timestamp(snapshot_dir))
    now_rounded = round_time(now)
    if snaptype == "hourly":
        hr_now = (now-monday).seconds//3600 + (now-monday).days*24
        hr_timestamp = (timestamp-monday).seconds//3600 + (timestamp-monday).days*24
        return hr_now - hr_timestamp
    elif snaptype == "daily":
        return ((now-monday).days - (timestamp-monday).days)
    elif snaptype == "weekly":
        return (now-monday).days//7 - (timestamp-monday).days//7
    elif snaptype == "monthly":
        return now.month - timestamp.month + 12*(now.year - timestamp.year)

def mark_snapshots(cfg,snapshots,snaptype):
    limit = cfg[snaptype+"_limit"]
    link_dir = join(cfg['directory'],"./incrbtrfs",snaptype)
    if not exists(link_dir):
        makedirs(link_dir)
    
    snapshots_base = [basename(snapshot.loc) for snapshot in snapshots]
    snapshots_i = [calc_index(snapshot.loc,snaptype) for snapshot in snapshots]
    for i in range(limit,-1,-1):
        index_dir = join(link_dir,str(i))
        if lexists(index_dir):
            remove(index_dir)
        if i in snapshots_i:
            last_index = list(reversed(snapshots_i)).index(i)
            s = list(reversed(snapshots))[last_index]
            s.keep = True
            #print("%2d %s"%(i,s.loc))
            symlink(s.loc,index_dir)

def mark_last(snapshots):
    snap = max(snapshots, key=lambda s: s.timestamp)
    last_dir = join(snap.loc,"..","..","last")
    if lexists(last_dir):
        remove(last_dir)
    symlink(snap.loc,last_dir)
    snap.keep = True
    return snap

def get_base_dir(subvolume):
    return join(subvolume,".incrbtrfs","timestamp")

def snapshot(subvolume):
    base = get_base_dir(subvolume)
    if not exists(base):
        makedirs(base)
    location = join(base,timestamp)
    command = ('/sbin/btrfs','subvolume','snapshot','-r',subvolume,location)
    check_call(command)
    return Snapshot(subvolume,timestamp)

def read_config(filename):
    subvolumes = []
    defaults = {
        "directory" : None,
        "send_to" : None,
        "hourly_limit" : 0,
        "daily_limit" : 0,
        "weekly_limit" : 0,
        "monthly_limit" : 0
        }
    config = ConfigParser(defaults)
    config.read(args.config)

    for section in config.sections():
        cfg = {}
        for k in ('directory','send_to'):
            cfg[k] = config.get(section,k)
        for k in ('hourly_limit','daily_limit','weekly_limit','monthly_limit'):
            cfg[k] = config.getint(section,k)
        if not cfg["directory"]:
            continue
        if not exists(cfg["directory"]):
            continue
        yield(cfg)

def clean_up(cfg,parent_timestamp=None):
    subvolume = cfg["directory"]
    base = get_base_dir(subvolume)
    snapshots = [Snapshot(subvolume,t) for t in listdir(base)]
    snapshots = sorted(snapshots,key=lambda s: s.timestamp,reverse=True)
    last = mark_last(snapshots)
    if cfg["hourly_limit"]:
        mark_snapshots(cfg,snapshots,"hourly")
    if cfg["daily_limit"]:
        mark_snapshots(cfg,snapshots,"daily")
    if cfg["weekly_limit"]:
        mark_snapshots(cfg,snapshots,"weekly")
    if cfg["monthly_limit"]:
        mark_snapshots(cfg,snapshots,"monthly")
    if parent_timestamp:
        for s in snapshots:
            if s.timestamp_str == parent_timestamp:
                s.keep = True

    if not any(snapshot.keep for snapshot in snapshots):
        print("None marked")
        return

    for snapshot in snapshots:
        if snapshot.keep:
            continue
        command = ("/sbin/btrfs","subvolume","delete",snapshot.loc)
        check_call(command)
    return last

def send_snapshot(snap,destination,parent_timestamp=None):
    rcv_base = get_base_dir(destination)
    if parent_timestamp:
        parent_loc = join(snap.subvolume,".incrbtrfs","timestamp",parent_timestamp)
        print("Performing Incremental Send/Receive")
        snd_cmd = ("/sbin/btrfs","send","-p",parent_loc,snap.loc)
    else:
        print("Performing Full Send/Receive")
        snd_cmd = ("/sbin/btrfs","send",snap.loc)
    rcv_cmd = ("/sbin/btrfs","receive",rcv_base)
    snd_p = Popen(snd_cmd,stdout=PIPE)
    rcv_p = Popen(rcv_cmd,stdin=snd_p.stdout)
    snd_p.stdout.close()
    rcv_p.communicate()
    
timestamp = now.strftime(timestamp_strp)

def get_parent(cfg):
    snd_subvolume = cfg["directory"]
    rcv_subvolume = cfg["send_to"]
    subvolume = cfg["directory"]
    snd_base = get_base_dir(snd_subvolume)
    snd_timestamps = listdir(snd_base)
    rcv_base = get_base_dir(rcv_subvolume)
    rcv_timestamps = listdir(rcv_base)
    timestamps = snd_timestamps + rcv_timestamps
    timestamps = sorted(timestamps,reverse=True)
    parent = None
    for t1,t2 in zip(timestamps[:-1],timestamps[1:]):
        if t1 == t2:
            parent = t1
            break
    return parent

if __name__ == "__main__":
    parser = ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-c","--config")
    group.add_argument("-s","--subvolume")
    args = parser.parse_args()

    if args.config:
        for cfg in read_config(args.config):
            try:
                snap = snapshot(cfg["directory"])
            except CalledProcessError:
                continue
            if cfg["send_to"]:
                parent_timestamp = get_parent(cfg)
                send_snapshot(snap,cfg["send_to"],parent_timestamp=parent_timestamp)
            last = clean_up(cfg,parent_timestamp=parent_timestamp)
    else:
        try:
            mark_last([snapshot(args.subvolume)])
        except CalledProcessError:
            pass
